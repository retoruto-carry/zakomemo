# ピクセルアート化 パフォーマンス分析

## 現在の実装のパフォーマンス特性

### 1. 描画サイズ
- **論理サイズ**: 320×240px（76,800ピクセル）
- **物理サイズ**: 論理サイズ × devicePixelRatio（高解像度では2倍や3倍）
- キャンバスサイズが小さくなったため、描画負荷は軽減されている

### 2. レンダリングループ
- **フレームレート**: 約45fps（`minFrameIntervalMs = 1000 / 45`）
- **間引き**: フレーム間隔が22ms未満の場合は描画をスキップ
- **最適化**: 不要な再描画を避ける

### 3. ピクセル単位描画の計算量

#### ソリッド/消しゴム描画
- **Bresenhamアルゴリズム**: O(n)で効率的（nは点間の距離）
- **重複排除**: Setを使用して同じピクセルの重複描画を回避
- **問題点**: 
  - ストロークの点が多い場合、Bresenhamの計算が多くなる
  - `pixels.forEach`で文字列のsplitとNumber変換が発生（オーバーヘッド）

#### パターン描画
- **ネストループ**: 太い線の場合、`(width * 2 + 1)^2`回のループ
  - width=16の場合: 33×33 = 1,089回
  - width=48の場合: 97×97 = 9,409回
- **問題点**: 
  - 太い線でパターン描画すると、計算量がO(width²)になる
  - 各ピクセルでタイル計算と配列アクセスが発生

### 4. パフォーマンスの懸念点

#### 高負荷になる可能性があるケース
1. **大量のストローク**: ストローク数が多い場合、毎フレーム全ストロークを再描画
2. **太い線でのパターン描画**: width=48でパターン描画すると、1ピクセルあたり約9,409回の計算
3. **文字列操作**: `pixels.forEach`で`split(",").map(Number)`が発生

#### スマホでの懸念
- 低性能デバイスでは、太い線でのパターン描画が重くなる可能性
- バッテリー消費が増える可能性

## 最適化の提案

### 優先度: 高

#### 1. 文字列操作の最適化
**現状**: `pixels.forEach((key) => { const [x, y] = key.split(",").map(Number); })`

**問題**: 文字列のsplitとNumber変換がオーバーヘッド

**改善案**: Setの代わりに`Map<number, Set<number>>`を使用
```typescript
const pixels = new Map<number, Set<number>>(); // x -> Set<y>
// 追加時
if (!pixels.has(x)) pixels.set(x, new Set());
pixels.get(x)!.add(y);
// 描画時
pixels.forEach((ys, x) => {
  ys.forEach((y) => {
    this.drawPixel(ctx, x, y, brushWidth, variant, stroke.kind);
  });
});
```

#### 2. パターン描画の最適化
**現状**: 太い線で各ピクセルを拡大描画

**改善案**: 
- 太い線の場合は、パターンタイルを拡大してから描画
- または、描画範囲を事前に計算して、必要な部分のみ描画

### 優先度: 中

#### 3. 描画の最適化
- 変更がないストロークは再描画しない（ダーティチェック）
- 画面外のピクセルは描画しない（クリッピング）

### 優先度: 低

#### 4. メモリ最適化
- 不要な中間データの削除
- ガベージコレクションの最適化

## 実測が必要な項目

1. **実際の描画時間**: プロファイラーで測定
2. **メモリ使用量**: 大量のストローク時のメモリ使用量
3. **スマホでの動作**: 実機での動作確認

## 推奨される対応

### 即座に対応すべき項目
1. 文字列操作の最適化（Setの代わりにMapを使用）
2. パフォーマンステストの追加

### 実測後に判断すべき項目
1. パターン描画の最適化（実測で問題があれば対応）
2. 描画の最適化（実測で問題があれば対応）


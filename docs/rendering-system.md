# 描画システムとキャッシュの仕組み

## 概要

Wiggly Ugomemo の描画システムは、ピクセルアート前提の ImageData ベースのレンダリングと、パフォーマンス最適化のための多層キャッシュシステムで構成されています。

## アーキテクチャ

### レンダリング方式

- **ImageData ベース**: すべての描画操作は`ImageData`に直接書き込まれ、フレームごとに 1 回だけ`putImageData`でキャンバスに反映
- **ピクセルパーフェクト**: 座標とブラシサイズは整数ピクセルにスナップ、アンチエイリアス無効
- **3 フレーム固定**: アニメーションは 3 フレーム（10fps、100ms 間隔）で固定

### キャッシュシステム

#### 1. フレームキャッシュ (`frameBitmaps`)

- **内容**: 3 フレーム分の`ImageBitmap`配列
- **用途**: アニメーションループで使用される現在のフレーム
- **更新タイミング**:
  - 新しいストローク追加時（差分描画）
  - 既存ストロークにポイント追加時（ポイント単位の差分描画）
  - キャッシュ無効化時（背景色変更、jitterConfig 変更、全消し）

#### 2. 履歴キャッシュ (`historyCache`)

- **内容**: `Map<drawingHash, HistoryCacheEntry>`
- **用途**: undo/redo 時の高速化
- **最大サイズ**: 5 個（最新 5 個の履歴状態を保持）
  - undo/redo を繰り返すと、新しいエントリが追加され、古いエントリが自動的に削除される
  - これにより、メモリ使用量は一定の範囲内に保たれる
- **更新タイミング**: すべてのフレームが生成された時（`renderFrameFromScratch`完了時）

#### 3. キャッシュメタデータ

- `cachedStrokeIds`: キャッシュ済みのストローク ID のセット
- `cachedStrokePointCounts`: ストローク ID ごとのポイント数（ポイント単位の差分描画用）
- `cachedDrawingHash`: 現在の Drawing のハッシュ
- `cachedJitterConfig`: 現在の jitterConfig

## 描画フロー

### リアルタイム描画時

1. **ストローク開始** (`pointerDown`)

   - 新しいストロークを作成
   - `isDrawingActive = true`を設定（バックグラウンド生成をスキップ）

2. **ストローク描画中** (`pointerMove`)

   - ポイントを追加
   - アニメーションループが続行

3. **フレーム取得** (`getFrameBitmap`)

   - 履歴キャッシュをチェック
   - 通常のキャッシュをチェック
   - 新しいストロークがある場合:
     - 新しいストローク全体を描画（差分描画）
   - 既存ストロークにポイント追加がある場合:
     - 新しいポイントだけを描画（ポイント単位の差分描画）
   - 要求されたフレームを同期的に生成
   - 他のフレームを非同期で生成（バックグラウンド）

4. **ストローク完了** (`pointerUp`)
   - `isDrawingActive = false`を設定
   - 履歴に追加

### 差分描画の仕組み

#### ストローク単位の差分描画

新しいストロークが追加された場合:

1. 前の`ImageBitmap`から`ImageData`を取得
2. 新しいストロークだけを描画
3. 新しい`ImageBitmap`を作成

#### ポイント単位の差分描画

既存のストロークにポイントが追加された場合:

1. 前の`ImageBitmap`から`ImageData`を取得
2. 新しいポイントだけを描画（前のポイントとの接続のため、1 つ前のポイントも含める）
3. 新しい`ImageBitmap`を作成

### キャッシュ無効化

以下の場合、キャッシュが無効化され、全再生成が行われます:

- **背景色変更**: `setBackgroundColor()`呼び出し時
- **jitterConfig 変更**: `setJitterConfig()`呼び出し時
- **全消し**: `clear()`呼び出し時
- **undo/redo**: 履歴キャッシュにヒットしない場合

### 履歴キャッシュの利用

undo/redo 時:

1. `drawingHash`を計算
2. 履歴キャッシュをチェック
3. ヒットした場合: 即座に`ImageBitmap`を返す（再生成不要）
4. ヒットしない場合: 全ストロークから再生成

## パフォーマンス最適化

### 時間計算量

- **差分描画**: O(N × P × W²) + O(A)
  - N = 新しいストローク/ポイント数
  - P = ポイント数/ストローク
  - W = ブラシ幅
  - A = キャンバス面積（ImageBitmap から ImageData を取得するコスト）
- **全再生成**: O(S × P × W²)
  - S = ストローク数
- **キャッシュヒット**: O(1)

### メモリ使用量

- **ImageData**: 約 1MB（384×256×4 バイト）
- **ImageBitmap キャッシュ**: 約 3MB（3 フレーム分）
- **履歴キャッシュ**: 最大約 15MB（最大 5 エントリ ×3 フレーム）
  - undo/redo を繰り返すと、新しいエントリが追加され、古いエントリが削除される
  - `MAX_HISTORY_CACHE_SIZE = 5` で制限されているため、メモリ使用量は一定の範囲内に保たれる
- **合計**: 最大約 19MB（モバイルでも許容範囲）

## 実装の詳細

### キャッシュキー

- **drawingHash**: `${width}x${height}:${strokes.length}:${stroke.id}:${points.length},...`
- **jitterConfig**: `{ amplitude, frequency }`（別途比較）

### フレーム生成の優先順位

1. **要求されたフレーム**: 同期的に生成（即座に返す）
2. **他のフレーム**: 非同期で生成（バックグラウンド）

### バックグラウンド生成の制御

- `isDrawingActive = true`の場合、バックグラウンド生成をスキップ
- `AbortController`でキャンセル可能


# 描画システムとキャッシュの仕組み

## 概要

Wiggly Ugomemoの描画システムは、ピクセルアート前提のImageDataベースのレンダリングと、パフォーマンス最適化のための多層キャッシュシステムで構成されています。

## アーキテクチャ

### レンダリング方式

- **ImageDataベース**: すべての描画操作は`ImageData`に直接書き込まれ、フレームごとに1回だけ`putImageData`でキャンバスに反映
- **ピクセルパーフェクト**: 座標とブラシサイズは整数ピクセルにスナップ、アンチエイリアス無効
- **3フレーム固定**: アニメーションは3フレーム（10fps、100ms間隔）で固定

### キャッシュシステム

#### 1. フレームキャッシュ (`frameBitmaps`)

- **内容**: 3フレーム分の`ImageBitmap`配列
- **用途**: アニメーションループで使用される現在のフレーム
- **更新タイミング**:
  - 新しいストローク追加時（差分描画）
  - 既存ストロークにポイント追加時（ポイント単位の差分描画）
  - キャッシュ無効化時（背景色変更、jitterConfig変更、全消し）

#### 2. 履歴キャッシュ (`historyCache`)

- **内容**: `Map<drawingHash, HistoryCacheEntry>`
- **用途**: undo/redo時の高速化
- **最大サイズ**: 5個（最新5個の履歴状態を保持）
- **更新タイミング**: すべてのフレームが生成された時

#### 3. キャッシュメタデータ

- `cachedStrokeIds`: キャッシュ済みのストロークIDのセット
- `cachedStrokePointCounts`: ストロークIDごとのポイント数（ポイント単位の差分描画用）
- `cachedDrawingHash`: 現在のDrawingのハッシュ
- `cachedJitterConfig`: 現在のjitterConfig

## 描画フロー

### リアルタイム描画時

1. **ストローク開始** (`pointerDown`)
   - 新しいストロークを作成
   - `isDrawingActive = true`を設定（バックグラウンド生成をスキップ）

2. **ストローク描画中** (`pointerMove`)
   - ポイントを追加
   - アニメーションループが続行

3. **フレーム取得** (`getFrameBitmap`)
   - 履歴キャッシュをチェック
   - 通常のキャッシュをチェック
   - 新しいストロークがある場合:
     - 新しいストローク全体を描画（差分描画）
   - 既存ストロークにポイント追加がある場合:
     - 新しいポイントだけを描画（ポイント単位の差分描画）
   - 要求されたフレームを同期的に生成
   - 他のフレームを非同期で生成（バックグラウンド）

4. **ストローク完了** (`pointerUp`)
   - `isDrawingActive = false`を設定
   - 履歴に追加

### 差分描画の仕組み

#### ストローク単位の差分描画

新しいストロークが追加された場合:
1. 前の`ImageBitmap`から`ImageData`を取得
2. 新しいストロークだけを描画
3. 新しい`ImageBitmap`を作成

#### ポイント単位の差分描画

既存のストロークにポイントが追加された場合:
1. 前の`ImageBitmap`から`ImageData`を取得
2. 新しいポイントだけを描画（前のポイントとの接続のため、1つ前のポイントも含める）
3. 新しい`ImageBitmap`を作成

### キャッシュ無効化

以下の場合、キャッシュが無効化され、全再生成が行われます:

- **背景色変更**: `setBackgroundColor()`呼び出し時
- **jitterConfig変更**: `setJitterConfig()`呼び出し時
- **全消し**: `clear()`呼び出し時
- **undo/redo**: 履歴キャッシュにヒットしない場合

### 履歴キャッシュの利用

undo/redo時:
1. `drawingHash`を計算
2. 履歴キャッシュをチェック
3. ヒットした場合: 即座に`ImageBitmap`を返す（再生成不要）
4. ヒットしない場合: 全ストロークから再生成

## パフォーマンス最適化

### 時間計算量

- **差分描画**: O(N × P × W²) + O(A)
  - N = 新しいストローク/ポイント数
  - P = ポイント数/ストローク
  - W = ブラシ幅
  - A = キャンバス面積（ImageBitmapからImageDataを取得するコスト）
- **全再生成**: O(S × P × W²)
  - S = ストローク数
- **キャッシュヒット**: O(1)

### メモリ使用量

- **ImageData**: 約1MB（384×256×4バイト）
- **ImageBitmapキャッシュ**: 約3MB（3フレーム分）
- **履歴キャッシュ**: 約15MB（5エントリ×3フレーム）
- **合計**: 約19MB（モバイルでも許容範囲）

## 実装の詳細

### キャッシュキー

- **drawingHash**: `${width}x${height}:${strokes.length}:${stroke.id}:${points.length},...`
- **jitterConfig**: `{ amplitude, frequency }`（別途比較）

### フレーム生成の優先順位

1. **要求されたフレーム**: 同期的に生成（即座に返す）
2. **他のフレーム**: 非同期で生成（バックグラウンド）

### バックグラウンド生成の制御

- `isDrawingActive = true`の場合、バックグラウンド生成をスキップ
- `AbortController`でキャンセル可能


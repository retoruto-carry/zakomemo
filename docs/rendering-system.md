# 描画システムとキャッシュの仕組み

## 概要

Wiggly Ugomemo の描画システムは、ピクセルアート前提の ImageData ベースのレンダリングと、パフォーマンス最適化のための多層キャッシュシステムで構成されています。

## アーキテクチャ

### レンダリング方式

- **ImageData ベース**: すべての描画操作は`ImageData`に直接書き込まれ、フレームごとに 1 回だけ`putImageData`でキャンバスに反映
- **ピクセルパーフェクト**: 座標とブラシサイズは整数ピクセルにスナップ、アンチエイリアス無効
- **3 フレーム固定**: アニメーションは 3 フレーム（10fps、100ms 間隔）で固定

### キャッシュシステム

#### 1. フレームキャッシュ (`frameBitmaps`)

- **内容**: 3 フレーム分の`ImageBitmap`配列
- **用途**: アニメーションループで使用される現在のフレーム
- **更新タイミング**:
  - 新しいストローク追加時（差分描画）
  - 既存ストロークにポイント追加時（ポイント単位の差分描画）
  - キャッシュ無効化時（背景色変更、jitterConfig 変更、全消し）

#### 2. 履歴キャッシュ (`historyCache`)

- **内容**: `Map<drawingHash, HistoryCacheEntry>`
- **用途**: undo/redo 時の高速化
- **最大サイズ**: 5 個（最新 5 個の履歴状態を保持）
  - undo/redo を繰り返すと、新しいエントリが追加され、古いエントリが自動的に削除される
  - これにより、メモリ使用量は一定の範囲内に保たれる
- **更新タイミング**: すべてのフレームが生成された時（`renderFrameFromScratch`完了時）

#### 3. キャッシュメタデータ

- `cachedStrokeIds`: キャッシュ済みのストローク ID のセット
- `cachedStrokePointCounts`: ストローク ID ごとのポイント数（ポイント単位の差分描画用）
- `cachedDrawingHash`: 現在の Drawing のハッシュ
- `cachedJitterConfig`: 現在の jitterConfig

## 描画フロー

### リアルタイム描画時

1. **ストローク開始**
   - 新しいストロークを作成
   - ストローク描画中は、バックグラウンド生成をスキップ（パフォーマンス保護）

2. **ストローク描画中**
   - ポイントを追加
   - アニメーションループが続行（約45fps）

3. **フレーム取得**
   - 履歴キャッシュをチェック（undo/redo用）
   - 通常のキャッシュをチェック
   - 新しいストロークがある場合:
     - 前のフレームに新しいストロークだけを描画（差分描画）
   - 既存ストロークにポイント追加がある場合:
     - 前のフレームに新しいポイントだけを描画（ポイント単位の差分描画）
   - 要求されたフレームを同期的に生成（即座に返す）
   - 他のフレームを非同期で生成（バックグラウンド、ブロックしない）

4. **ストローク完了**
   - 履歴に追加
   - バックグラウンド生成が再開される

### 差分描画の仕組み

#### ストローク単位の差分描画

新しいストロークが追加された場合:
- 前のフレームの画像データを取得
- 新しいストロークだけを描画
- 新しいフレーム画像を作成

これにより、全ストロークを再描画する必要がなく、約50倍高速化されます。

#### ポイント単位の差分描画

既存のストロークにポイントが追加された場合:
- 前のフレームの画像データを取得
- 新しいポイントだけを描画（前のポイントとの接続のため、1つ前のポイントも含める）
- 新しいフレーム画像を作成

これにより、ストローク全体を再描画する必要がなく、さらに効率的です。

### キャッシュ無効化

以下の場合、キャッシュが無効化され、全再生成が行われます:

- **背景色変更**: 背景色が変更された場合
- **jitter設定変更**: 揺れの振幅や周波数が変更された場合
- **全消し**: キャンバスがクリアされた場合
- **undo/redo**: 履歴キャッシュにヒットしない場合

### undo/redo 時の動作

undo/redo を実行すると:

1. 通常のキャッシュはクリアされる（履歴キャッシュは保持）
2. 履歴キャッシュをチェック
3. **ヒットした場合**: 即座にフレーム画像を返す（再生成不要、実質0ms）
4. **ヒットしない場合**: 全ストロークから再生成（O(S × P × W²)）

undo/redo を繰り返すと、履歴キャッシュに新しいエントリが追加されますが、最大5個までしか保持されないため、メモリ使用量は一定の範囲内に保たれます。

## パフォーマンス最適化

### 時間計算量

- **差分描画**: O(N × P × W²) + O(A)
  - N = 新しいストローク/ポイント数
  - P = ポイント数/ストローク
  - W = ブラシ幅
  - A = キャンバス面積（ImageBitmap から ImageData を取得するコスト）
- **全再生成**: O(S × P × W²)
  - S = ストローク数
- **キャッシュヒット**: O(1)

### メモリ使用量

- **ImageData**: 約 1MB（384×256×4 バイト）
- **ImageBitmap キャッシュ**: 約 3MB（3 フレーム分）
- **履歴キャッシュ**: 最大約 15MB（最大 5 エントリ ×3 フレーム）
  - undo/redo を繰り返すと、新しいエントリが追加され、古いエントリが削除される
  - `MAX_HISTORY_CACHE_SIZE = 5` で制限されているため、メモリ使用量は一定の範囲内に保たれる
- **合計**: 最大約 19MB（モバイルでも許容範囲）

## パフォーマンス特性

### 最適化されているケース

1. **新しいストローク追加時**: 要求されたフレームのみ同期的に生成（約3倍高速化）
2. **undo/redo時（履歴キャッシュヒット）**: 即座に取得（実質0ms）
3. **アニメーションループ（キャッシュヒット）**: 既存のフレーム画像を返す（実質0ms）

### パフォーマンスがかかるケース

1. **undo/redo時（履歴キャッシュミス）**: 全ストロークから再生成（O(S × P × W²)）
2. **新しいストローク追加時（前のフレーム画像がない場合）**: 全ストロークから再生成
   - 通常は差分描画が使われるが、前のフレーム画像がない場合は全ストロークを描画する必要がある
   - 初回のストローク追加時は、ストロークが1個だけなので軽量
3. **全消し時**: 空のキャンバスから再生成（軽量）

### バックグラウンド生成の制御

- ストローク描画中は、バックグラウンド生成をスキップ（パフォーマンス保護）
- キャンセル可能な非同期処理で実装


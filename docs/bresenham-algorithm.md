# Bresenham アルゴリズム 詳細解説

## 概要

Bresenham アルゴリズムは、2 点間をピクセル単位で結ぶための効率的なアルゴリズムです。浮動小数点演算を使わず、整数演算のみで実装できるため、高速です。

## アルゴリズムの原理

### 1. 基本的な考え方

2 点間の直線を描画する際、各ピクセルについて「理想的な直線に最も近いピクセル」を選択します。

```
例: (0,0) -> (5,3) の線を描画する場合

理想的な直線: y = (3/5) * x = 0.6 * x

x=0: y=0.0 -> ピクセル(0,0)を選択
x=1: y=0.6 -> ピクセル(1,1)を選択（0.6に最も近い）
x=2: y=1.2 -> ピクセル(2,1)を選択（1.2に最も近い）
x=3: y=1.8 -> ピクセル(3,2)を選択（1.8に最も近い）
x=4: y=2.4 -> ピクセル(4,2)を選択（2.4に最も近い）
x=5: y=3.0 -> ピクセル(5,3)を選択

結果: [(0,0), (1,1), (2,1), (3,2), (4,2), (5,3)]
```

### 2. 誤差の管理

Bresenham アルゴリズムは、誤差（error）を使って次のピクセルを決定します。

- **err**: 現在のピクセルから理想的な直線までの誤差
- **e2 = 2 \* err**: 誤差の 2 倍（判定用）

### 3. アルゴリズムのステップ

#### 初期化

```typescript
const dx = Math.abs(x1 - x0); // X方向の距離
const dy = Math.abs(y1 - y0); // Y方向の距離
const sx = x0 < x1 ? 1 : -1; // X方向の符号（+1 or -1）
const sy = y0 < y1 ? 1 : -1; // Y方向の符号（+1 or -1）

let x = x0;
let y = y0;
let err = dx - dy; // 初期誤差
```

#### ループ処理

```typescript
while (x !== x1 || y !== y1) {
  const e2 = 2 * err;

  // X方向に進むか判定
  if (e2 > -dy) {
    err -= dy;
    x += sx;
  }

  // Y方向に進むか判定
  if (e2 < dx) {
    err += dx;
    y += sy;
  }

  points.push({ x, y });
}
```

### 4. 動作例: (0,0) -> (5,3)

```
初期値:
  x=0, y=0, err=2 (dx=5, dy=3)

ステップ1:
  e2 = 4
  e2 > -dy (4 > -3) → true → x += 1, err -= 3 → err=2-3=-1
  e2 < dx (4 < 5) → true → y += 1, err += 5 → err=-1+5=4
  結果: (1,1), err=4

ステップ2:
  e2 = 8
  e2 > -dy (8 > -3) → true → x += 1, err -= 3 → err=4-3=1
  e2 < dx (8 < 5) → false → Y方向には進まない
  結果: (2,1), err=1

ステップ3:
  e2 = 2
  e2 > -dy (2 > -3) → true → x += 1, err -= 3 → err=1-3=-2
  e2 < dx (2 < 5) → true → y += 1, err += 5 → err=-2+5=3
  結果: (3,2), err=3

ステップ4:
  e2 = 6
  e2 > -dy (6 > -3) → true → x += 1, err -= 3 → err=3-3=0
  e2 < dx (6 < 5) → false → Y方向には進まない
  結果: (4,2), err=0

ステップ5:
  e2 = 0
  e2 > -dy (0 > -3) → true → x += 1, err -= 3 → err=0-3=-3
  e2 < dx (0 < 5) → true → y += 1, err += 5 → err=-3+5=2
  結果: (5,3), err=2

最終結果: [(0,0), (1,1), (2,1), (3,2), (4,2), (5,3)]
```

## アルゴリズムの特徴

### 1. 整数演算のみ

- 浮動小数点演算を使わない
- 除算を使わない（2 倍の乗算のみ）
- 高速で正確

### 2. 8 方向に対応

- 水平線（右/左）
- 垂直線（上/下）
- 斜め線（4 方向）

### 3. 計算量

- 時間計算量: O(n)（n は点間の距離）
- 空間計算量: O(n)（結果の配列）

## 実装の詳細

### 誤差の更新ルール

1. **X 方向に進む場合**: `err -= dy`

   - Y 方向の距離分だけ誤差を減らす

2. **Y 方向に進む場合**: `err += dx`
   - X 方向の距離分だけ誤差を増やす

### 判定条件

- `e2 > -dy`: X 方向に進むべきか判定
- `e2 < dx`: Y 方向に進むべきか判定

これらの条件は、理想的な直線に最も近いピクセルを選択するためのものです。

## パフォーマンス

### 最適化ポイント

1. **整数演算のみ**: 浮動小数点演算より高速
2. **分岐の最小化**: 条件分岐が少ない
3. **メモリアクセスの最適化**: 配列への追加のみ

### 計算量の比較

- **Bresenham アルゴリズム**: O(n)（n は点間の距離）
- **単純な線形補間**: O(n)だが浮動小数点演算が必要
- **Canvas API の lineTo**: ブラウザ実装に依存（通常は最適化されているが、ピクセル単位の制御が困難）

## 使用例

### 通常のペン（ソリッドブラシ）

```typescript
// 点と点の間をBresenhamアルゴリズムで結ぶ
const linePixels = bresenhamLine(prevX, prevY, x, y);

// 各ピクセルを描画
linePixels.forEach((pixel) => {
  drawPixel(ctx, pixel.x, pixel.y, brushWidth);
});
```

### パターンブラシ

```typescript
// 同じくBresenhamアルゴリズムで点と点の間を結ぶ
const linePixels = bresenhamLine(prevX, prevY, x, y);

// 各ピクセルについて、パターンのタイル位置を計算して描画
linePixels.forEach((pixel) => {
  drawPatternPixel(ctx, pixel.x, pixel.y, brushWidth, tile);
});
```

## 太い線の描画

Bresenham アルゴリズム自体は 1 ピクセル幅の線（中心線）を描画しますが、実際の実装では太い線（width > 1）も描画できます。

### 実装方法

1. **Bresenham アルゴリズムで中心線を取得**

   - 2 点間の中心線上のピクセル座標を取得
   - 例: `[(0,0), (1,1), (2,1), (3,2), (4,2), (5,3)]`

2. **各ピクセルについて太さを適用**
   - 各中心線上のピクセルについて、太さに応じて拡大描画
   - width=1: `ctx.fillRect(x, y, 1, 1)`（1 ピクセル）
   - width>1: `ctx.arc(x, y, Math.floor(width / 2), 0, Math.PI * 2)`（円形）

### 描画の流れ

```
例: width=3 の線を描画する場合

1. Bresenham アルゴリズムで中心線を取得
   [(0,0), (1,1), (2,1), (3,2), (4,2), (5,3)]

2. 各中心線上のピクセルについて、半径1.5の円を描画
   - (0,0) に半径1.5の円を描画
   - (1,1) に半径1.5の円を描画
   - (2,1) に半径1.5の円を描画
   - ...

3. 結果: 太さ3ピクセルの線が描画される
```

### 重複排除

複数の円が重なる場合、同じピクセルを複数回描画することになりますが、Canvas API の `fill()` は自動的に重複を処理します。ただし、パフォーマンス最適化のため、`Map<number, Set<number>>` で重複を排除しています。

### パフォーマンス最適化

#### 従来の方法（最適化前）

- **中心線の計算**: O(n)（n は点間の距離）
- **各ピクセルの描画**: O(n × width²)（各中心線上のピクセルについて、半径 width/2 の円を描画）
  - 各中心線上のピクセルについて、`ctx.arc()`を呼び出して円を描画
  - 重複するピクセルが多数発生する

#### 最適化後の方法

- **中心線の計算**: O(n)（n は点間の距離）
- **領域の計算**: O(n × width²)（各中心線上のピクセルについて、周囲のピクセルを計算）
- **重複排除**: `Map<number, Set<number>>`を使用して重複を排除
- **描画**: O(実際のピクセル数)（重複排除後のピクセルのみを描画）

#### 最適化の効果

- **重複排除**: 複数の円が重なる場合、同じピクセルを複数回描画することを避ける
- **描画回数の削減**: 実際の描画回数は、理論的な O(n × width²) より大幅に削減される
- **例**: width=5 の線を描画する場合、中心線上の各ピクセルについて半径 2 の円を描画すると、理論的には 13 ピクセル × n 回の描画が必要ですが、重複排除により実際の描画回数は削減される

## まとめ

Bresenham アルゴリズムは、ピクセル単位の線描画に最適なアルゴリズムです。整数演算のみで実装でき、高速で正確です。ピクセルアートの描画システムでは、このアルゴリズムを使って点と点の間を滑らかに結び、各中心線上のピクセルについて太さを適用することで、太い線も描画できます。

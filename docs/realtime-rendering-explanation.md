# リアルタイム描画時の処理について

## 現在の実装

### リアルタイム描画時の動作

#### ケース1: **キャッシュが有効で新しいストロークがない場合**
```
getFrameBitmap()
  → キャッシュをチェック
  → 新しいストロークがない（newStrokes.length === 0）
  → 既存のImageBitmapを返す（再生成しない）✅
```

**パフォーマンス**: 実質0ms（ImageBitmapの取得のみ）

#### ケース2: **新しいストロークがある場合**
```
getFrameBitmap()
  → キャッシュをチェック
  → 新しいストロークがある（newStrokes.length > 0）
  → renderFrameFromScratch() を呼び出し
    → ImageDataを初期化（背景色でクリア）
    → 全ストロークを描画 ⚠️
      for (const stroke of drawing.strokes) {
        this.renderStroke(stroke, jittered, frameElapsedTimeMs);
      }
    → ImageBitmapを作成
```

**パフォーマンス**: O(S × P × W²)
- S = ストローク数
- P = ポイント数/ストローク
- W = ブラシ幅

**重要**: 新しいストロークが1つ追加されても、**全ストロークから再生成**している

## なぜ全ストロークから再生成するのか？

### 以前の実装（差分描画）の問題

以前は`renderFrameWithDiff`という差分描画の実装がありましたが、以下の問題により削除されました：

1. **消しゴムの問題**:
   - 消しゴムで描画すると、既存のピクセルを消す
   - 差分描画では、新しいストロークだけを描画するため、消しゴムの効果が正しく反映されない
   - 全フレームで一貫性が保てない

2. **全消しの問題**:
   - 全消し後、1フレームだけが更新され、他のフレームが古いままになる
   - アニメーションで不整合が発生

3. **フレーム間の一貫性**:
   - アニメーションでは3フレームすべてが必要
   - 差分描画では、要求されたフレームだけが更新される
   - 他のフレームが古いままになる可能性がある

### 現在の実装の利点

1. **一貫性**: すべてのフレームが同じ状態から生成される
2. **正確性**: 消しゴムや全消しが正しく動作する
3. **シンプル**: 実装が単純で、バグが発生しにくい

### パフォーマンスへの影響

**現在の実装**:
- 新しいストローク追加時: 全ストロークから再生成（O(S × P × W²)）
- ただし、要求されたフレームのみ同期的に生成（他のフレームは非同期）

**以前の差分描画**:
- 新しいストローク追加時: 新しいストロークのみ描画（O(N × P × W²)）
- ただし、フレーム間の一貫性の問題があった

**トレードオフ**:
- パフォーマンス: 差分描画の方が高速（約50倍）
- 正確性: 全再生成の方が正確（一貫性が保証される）

## 最適化の可能性

### 将来的な改善案

#### オプション1: 差分描画の再実装（改善版）

```typescript
// 新しいストロークのみを描画
// ただし、消しゴムの場合は全再生成
if (newStrokes.some(s => s.kind === "erase")) {
  // 消しゴムの場合は全再生成
  return renderFrameFromScratch(...);
} else {
  // 通常のストロークの場合は差分描画
  return renderFrameWithDiff(...);
}
```

**問題点**:
- 実装が複雑になる
- 消しゴムと通常のストロークが混在する場合の処理が難しい

#### オプション2: 現在の実装を維持

**推奨**:
- 現在の実装で十分なパフォーマンスが得られている
- 正確性と一貫性が優先される
- 実装がシンプルで保守しやすい

## まとめ

### リアルタイム描画時の処理

| ケース | 処理 | パフォーマンス |
|--------|------|---------------|
| **キャッシュヒット** | 既存のImageBitmapを返す | 実質0ms ✅ |
| **新しいストローク追加** | 全ストロークから再生成 | O(S × P × W²) ⚠️ |

### 重要なポイント

1. **新しいストロークがある場合、全ストロークから再生成している**
2. **理由**: フレーム間の一貫性と正確性を保証するため
3. **パフォーマンス**: 要求されたフレームのみ同期的に生成（他のフレームは非同期）
4. **最適化**: 現時点では不要（十分なパフォーマンスが得られている）

